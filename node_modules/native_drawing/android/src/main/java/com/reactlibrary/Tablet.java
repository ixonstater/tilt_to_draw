package com.reactlibrary;

import java.lang.Runnable;
import java.lang.Thread;
import android.view.SurfaceView;
import android.view.SurfaceHolder;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Color;
import android.graphics.Path;
import android.graphics.Bitmap;
import android.graphics.Matrix;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.app.Activity;
import android.content.ContextWrapper;
import android.view.WindowManager;
import android.util.DisplayMetrics;
import react.debuglogmanager.Logger;

const int MAX_PATH_LEN = 1600;

public class Tablet extends SurfaceView{
  private SurfaceHolder holder;
  private Paint linePaint;
  private Paint circlePaint;
  private int bgColor;
  private Path pathOne;
  private Path pathTwo;
  private Path pathInUse;
  private Bitmap imageDump;
  private Matrix matrix;
  private Thread bitmapMergeThread;
  private Runnable bitmapMergeRunnable;
  private Boolean pathOneInUse = true;
  private Boolean bitmapReadyToDraw = true;
  private int pathLen = 0;
  private Context ctx;
  private Boolean ready = false;
  private Boolean canvasReady = true;
  private Activity activityRef;
  private DisplayMetrics metrics;
  private int windowHeight;
  private int windowWidth;
  private float circleRadius;
  private float[] previousCoords = {0,0};



  public Tablet(Context context){
    super(context);
    this.ctx = context;
    this.linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    this.linePaint.setStyle(Paint.Style.STROKE);
    this.linePaint.setStrokeWidth(this.circleRadius);
    this.circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    this.holder = getHolder();
    this.pathOne = new Path();
    this.pathTwo = new Path();
    this.pathInUse = this.pathOne;
    this.bgColor = Color.BLACK;
    this.metrics = new DisplayMetrics();
    this.activityRef = (Activity)(((ContextWrapper)this.ctx).getBaseContext());
    this.activityRef.getWindowManager().getDefaultDisplay().getMetrics(this.metrics);
    this.windowHeight = this.metrics.heightPixels;
    this.windowWidth = this.metrics.widthPixels;
    this.matrix = new Matrix();
  }

  public void maxPathLengthReached(){
    this.pathLen = 0;
    if(this.pathOneInUse){
      this.pathInUse = this.pathTwo;
      this.pathOneInUse = false;
    } else {
      this.pathInUse = this.pathOne;
      this.pathOneInUse = true;
    }
  }

  public void draw(float x, float y){
    x = x / 100 * this.windowWidth;
    y = y / 100 * this.windowHeight;
    if(x == this.previousCoords[0] && y == this.previousCoords[1]){
      return;
    }else if(this.pathLen >= 1000){
      this.maxPathLengthReached();
    }
    this.setCanvasReady(false);
    Canvas canvas = this.holder.lockCanvas();
    this.pathInUse.lineTo(x, y);
    this.pathLen += 1;
    if(canvas != null){
      canvas.drawColor(this.bgColor);
      canvas.drawPath(this.pathOne, this.linePaint);
      canvas.drawPath(this.pathTwo, this.linePaint);
      canvas.drawCircle(x, y, this.circleRadius, this.circlePaint);
      if(this.bitmapReadyToDraw){
        canvas.drawBitmap(this.imageDump, this.matrix, this.linePaint);
      }
      this.holder.unlockCanvasAndPost(canvas);
    }
    this.previousCoords[0] = x;
    this.previousCoords[1] = y;
    this.setCanvasReady(true);
  }

  public void setStartingCoords(){
    this.pathInUse.moveTo(this.windowWidth / 2, this.windowHeight / 2);
  }

  public void setReady(Boolean val){
    this.ready = val;
  }

  public Boolean isReady(){
    return this.ready;
  }

  public Boolean isCanvasReady(){
    return this.canvasReady;
  }

  public void setCanvasReady(Boolean val){
    this.canvasReady = val;
  }

  public void setLineColor(String color){
    this.linePaint.setColor(Color.parseColor(color));
  }

  public void setCircleColor(String color){
    this.circlePaint.setColor(Color.parseColor(color));
  }

  public void setBGColor(String color){
    this.bgColor = Color.parseColor(color);
  }

  public void setCircleRadius(float radius){
    this.circleRadius = radius;
  }

  public void updateLineWidth(){
    this.linePaint.setStrokeWidth(this.circleRadius);
  }

  @Override
  protected void onAttachedToWindow(){
    super.onAttachedToWindow();
    this.activityRef.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    this.setSystemUiVisibility(this.SYSTEM_UI_FLAG_IMMERSIVE | this.SYSTEM_UI_FLAG_HIDE_NAVIGATION | this.SYSTEM_UI_FLAG_FULLSCREEN);
  }

  @Override
  protected void onDetachedFromWindow(){
    super.onDetachedFromWindow();
    this.activityRef.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
  }

  class BitmapMerger implements Runnable{
    public BitmapMerger(){
      
    }
  
    public void run(){
      
    }
  }
}